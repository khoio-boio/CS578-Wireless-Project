/*
    ============================================================================
    DEVICE: dev1 (Arduino R4 WiFi)
    PURPOSE:
      - Listens for WIFI UDP commands broadcast on LAN
      - Executes door servo actions (e.g., CLOSE_DOOR)
      - Sends ACK messages back to senders (PC or controller)
      - Optional IR remote support for local testing
    ============================================================================
*/

#include <WiFiS3.h>
#include <WiFiUdp.h>
#include <IRremote.hpp>
#include <Servo.h>

/* ============================================================================
 *  PHYSICAL HARDWARE SETUP
 * ============================================================================ */
const byte IR_RECEIVE_PIN = 2;   // IR receiver OUT pin → D2
Servo myservo;                   // Servo to actuate the door

/* ============================================================================
 *  WIFI / UDP CONFIGURATION
 * ============================================================================ */
const char* WIFI_SSID     = "lefish";
const char* WIFI_PASSWORD = "oogabooga";
const uint16_t UDP_PORT   = 4210;                    // Port for all communication
IPAddress broadcastIp(172, 20, 10, 15);            // Local subnet broadcast
const char* DEVICE_ID = "dev1";                      // This device's identity tag
bool isSleeping = false;

WiFiUDP udp;
const size_t UDP_BUFFER_SIZE = 256;
char incomingBuffer[UDP_BUFFER_SIZE];

/* ============================================================================
 *  WIFI CONNECTION HELPER
 * ============================================================================ */
void connectWiFi() {
  Serial.print("[");
  Serial.print(DEVICE_ID);
  Serial.print("] Connecting to Wi-Fi: ");
  Serial.println(WIFI_SSID);

  int status = WL_IDLE_STATUS;
  int attempts = 0;

  // Try 40 × (500ms) = 20 seconds max
  while (status != WL_CONNECTED && attempts < 40) {
    status = WiFi.begin(WIFI_SSID, WIFI_PASSWORD);
    attempts++;
    delay(500);
    Serial.print(".");
  }
  Serial.println();

  if (status == WL_CONNECTED) {
    Serial.print("[");
    Serial.print(DEVICE_ID);
    Serial.print("] Wi-Fi connected. IP = ");
    Serial.println(WiFi.localIP());
  } else {
    Serial.print("[");
    Serial.print(DEVICE_ID);
    Serial.println("] Wi-Fi connection FAILED.");
  }
}

/* ============================================================================
 *  MESSAGE PARSING UTIL (extract key=value)
 * ============================================================================ */
String extractField(const String& msg, const String& key) {
  String pattern = key + "=";
  int start = msg.indexOf(pattern);
  if (start == -1) return "";

  start += pattern.length();
  int end = msg.indexOf(';', start);
  if (end == -1) end = msg.length();

  return msg.substring(start, end);
}

/* ============================================================================
 *  SEND ACK PACKET
 *  Sent whenever the device receives a CMD meant for it
 * ============================================================================ */
void sendAck(const IPAddress& controllerIp,
             uint16_t controllerPort,
             const String& origin,
             const String& cmdId,
             const String& status,
             const String& scheduled,
             const String& recurring,
             const String& nextTime,
             const String& extraFields = "") {
  // Build base ACK message
  String ackMsg = "ACK;origin=" + origin +
                  ";id=" + cmdId +
                  ";device=" + String(DEVICE_ID) +
                  ";status=" + status +
                  ";scheduled=" + scheduled +
                  ";recurring=" + recurring +
                  ";next=" + nextTime;

  // Optional extra fields, e.g. ";state=ASLEEP;uptime_ms=1234;rssi=-60"
  ackMsg += extraFields;

  // Broadcast ACK on the standard port
  udp.beginPacket(broadcastIp, UDP_PORT);
  udp.print(ackMsg);
  udp.endPacket();

  Serial.print("[");
  Serial.print(DEVICE_ID);
  Serial.print("] Sent ACK: ");
  Serial.println(ackMsg);
}


/* ============================================================================
 *  DOOR ACTIONS
 * ============================================================================ */
void closeDoor() {
  // Move servo to closed
  myservo.write(0);
  delay(1000);

  // Reset servo position
  myservo.write(180);
}

/* ============================================================================
 *  SETUP
 * ============================================================================ */
void setup() {
  myservo.attach(9);   // Servo connected to pin 9

  Serial.begin(9600);
  while (!Serial) {}   // Ensure serial is ready

  // Start IR receiver (optional)
  Serial.println("IR Receiver test. Point remote and press buttons...");
  IrReceiver.begin(IR_RECEIVE_PIN, ENABLE_LED_FEEDBACK);

  // Connect to WiFi
  connectWiFi();

  // Start UDP listener
  if (udp.begin(UDP_PORT)) {
    Serial.print("[");
    Serial.print(DEVICE_ID);
    Serial.print("] Listening on UDP port ");
    Serial.println(UDP_PORT);
  } else {
    Serial.print("[");
    Serial.print(DEVICE_ID);
    Serial.println("] Failed to start UDP listener!");
  }
}

/* ============================================================================
 *  MAIN LOOP
 * ============================================================================ */
void loop() {

  /* ---------------------------------------------------------
   *  IR REMOTE HANDLING
   * --------------------------------------------------------- */
  if (IrReceiver.decode()) {
    Serial.print("IR Command: ");
    Serial.println(IrReceiver.decodedIRData.command);

    // IR command "1" closes the door
    if (IrReceiver.decodedIRData.command == 12) {
      closeDoor();
    }

    IrReceiver.resume();
  }

  /* ---------------------------------------------------------
   *  WIFI RECONNECT WATCHDOG
   * --------------------------------------------------------- */
  if (WiFi.status() != WL_CONNECTED) {
    Serial.print("[");
    Serial.print(DEVICE_ID);
    Serial.println("] WiFi lost! Reconnecting...");
    connectWiFi();
  }

  /* ---------------------------------------------------------
   *  UDP PACKET HANDLING
   * --------------------------------------------------------- */
  int packetSize = udp.parsePacket();
  if (packetSize > 0) {

    // Read packet
    int len = udp.read(incomingBuffer, UDP_BUFFER_SIZE - 1);
    if (len > 0) incomingBuffer[len] = '\0';

    String msg = String(incomingBuffer);
    IPAddress senderIp  = udp.remoteIP();
    uint16_t senderPort = udp.remotePort();

    Serial.print("[");
    Serial.print(DEVICE_ID);
    Serial.print("] UDP from ");
    Serial.print(senderIp);
    Serial.print(":");
    Serial.print(senderPort);
    Serial.print(" -> ");
    Serial.println(msg);

    /* ---------------------------------------------------------
     *  PROCESS CMD MESSAGES
     * --------------------------------------------------------- */
    if (msg.startsWith("CMD;")) {

      // Extract fields
      String origin    = extractField(msg, "origin");
      String cmdId     = extractField(msg, "id");
      String target    = extractField(msg, "target");
      String action    = extractField(msg, "action");
      String scheduled = extractField(msg, "scheduled");
      String recurring = extractField(msg, "recurring");
      String nextTime  = extractField(msg, "next");

      Serial.print("[");
      Serial.print(DEVICE_ID);
      Serial.print("] CMD parsed: origin=");
      Serial.print(origin);
      Serial.print(", id=");
      Serial.print(cmdId);
      Serial.print(", target=");
      Serial.print(target);
      Serial.print(", action=");
      Serial.print(action);
      Serial.print(", scheduled=");
      Serial.print(scheduled);
      Serial.print(", recurring=");
      Serial.print(recurring);
      Serial.print(", next=");
      Serial.println(nextTime);

            // Check if this command is for me (or ALL)
      if (target == DEVICE_ID || target == "ALL") {
        Serial.print("[");
        Serial.print(DEVICE_ID);
        Serial.print("] Command for me. action=");
        Serial.println(action);

        bool recognized        = false;
        String status          = "UNKNOWN_ACTION";
        String extraFields     = "";   // for STATUS metrics

        // -------------------------------
        // Special commands (always obey)
        // -------------------------------

        if (action == "SLEEP") {
          // Enter sleep mode: ignore physical actions until WAKEUP
          isSleeping = true;
          recognized = true;
          status     = "OK";

          Serial.print("[");
          Serial.print(DEVICE_ID);
          Serial.println("] Entering SLEEP mode.");

        } else if (action == "WAKEUP") {
          // Exit sleep mode
          isSleeping = false;
          recognized = true;
          status     = "OK";

          Serial.print("[");
          Serial.print(DEVICE_ID);
          Serial.println("] Waking up (leaving SLEEP mode).");

        } else if (action == "STATUS") {
          // STATUS always responds, regardless of sleep
          recognized = true;
          status     = "STATUS_OK";

          // Gather basic metrics
          unsigned long uptime = millis();
          long rssi = WiFi.RSSI();
          const char* stateStr = isSleeping ? "ASLEEP" : "AWAKE";

          extraFields =
            ";state="     + String(stateStr) +
            ";uptime_ms=" + String(uptime) +
            ";rssi="      + String(rssi);

          Serial.print("[");
          Serial.print(DEVICE_ID);
          Serial.print("] STATUS requested. state=");
          Serial.print(stateStr);
          Serial.print(", uptime_ms=");
          Serial.print(uptime);
          Serial.print(", rssi=");
          Serial.println(rssi);

        // -------------------------------
        // Normal action commands
        // -------------------------------
        } else if (action == "CLOSE_DOOR") {
          recognized = true;

          if (isSleeping) {
            // Valid command, but we are asleep → DO NOT move servo
            status = "ASLEEP_NO_ACTION";

            Serial.print("[");
            Serial.print(DEVICE_ID);
            Serial.println("] CLOSE_DOOR received but device is ASLEEP. No action taken.");
          } else {
            // Normal behavior: perform the action
            closeDoor();
            status = "OK";

            Serial.print("[");
            Serial.print(DEVICE_ID);
            Serial.println("] CLOSE_DOOR executed.");
          }

        } else {
          // Unknown/unsupported action
          recognized = false;
          status     = "UNKNOWN_ACTION";

          Serial.print("[");
          Serial.print(DEVICE_ID);
          Serial.print("] WARNING: Unknown action '");
          Serial.print(action);
          Serial.println("' – no movement performed.");
        }

        // Send ACK back to sender
        if (cmdId.length() > 0) {
          String safeOrigin    = (origin.length()    > 0) ? origin    : "UNKNOWN";
          String safeScheduled = (scheduled.length() > 0) ? scheduled : "0";
          String safeRecurring = (recurring.length() > 0) ? recurring : "0";
          String safeNext      = (nextTime.length()  > 0) ? nextTime  : "NONE";

          sendAck(senderIp,
                  senderPort,
                  safeOrigin,
                  cmdId,
                  status,
                  safeScheduled,
                  safeRecurring,
                  safeNext,
                  extraFields);
        }

      } else {
        Serial.print("[");
        Serial.print(DEVICE_ID);
        Serial.println("] Command not for me, ignoring.");
      }
    }

  delay(5);  // Prevent CPU hogging
  }
}

/* ============================================================================
 *  END OF FILE
 * ============================================================================ */
