/*
    Code developed for an ESP32 WROOM DEVKIT
*/

#include <WiFi.h>
#include <WiFiUdp.h>

// ======= WIFI / UDP CONFIG =======
const char* WIFI_SSID     = "BlueHouse";
const char* WIFI_PASSWORD = "dynamicink599";
const uint16_t UDP_PORT   = 4210;
IPAddress broadcastIp(192, 168, 86, 255);
const char* CONTROLLER_ID = "controller";
// ======= END WIFI / UDP CONFIG =======

// ========== PHYSICAL
// Button on D2 (which is GPIO 2 on many ESP32 dev boards)
const int BUTTON_PIN = 2;   // connect button between D2 and GND

// ====== GLOBALS ======
WiFiUDP udp;

const size_t UDP_BUFFER_SIZE = 256;
char incomingBuffer[UDP_BUFFER_SIZE];

unsigned long lastTickTime        = 0;
const unsigned long TICK_INTERVAL = 5000;  // 5 seconds

uint32_t commandCounter = 0;  // increments for each command we send

// ===== BUTTON DEBOUNCE GLOBALS =====
int lastStableButtonState = HIGH;   // because INPUT_PULLUP idle = HIGH
int lastReading = HIGH;
unsigned long lastDebounceTime = 0;
const unsigned long debounceDelay = 50;  // ms

// ====== HELPERS ======

void logWifiStatus() {
  wl_status_t status = WiFi.status();
  Serial.print("[");
  Serial.print(CONTROLLER_ID);
  Serial.print("] WiFi status = ");
  Serial.print(status);  // 3 == WL_CONNECTED
  if (status == WL_CONNECTED) {
    Serial.print(" (CONNECTED), IP = ");
    Serial.print(WiFi.localIP());
    Serial.print(", RSSI = ");
    Serial.print(WiFi.RSSI());
    Serial.println(" dBm");
  } else {
    Serial.println(" (NOT CONNECTED)");
  }
}

// Build command string in the format:
// CMD;id=123;target=dev1;action=CLOSE_DOOR
String buildCommand(uint32_t cmdId,
                    const String& origin,
                    const String& target,
                    const String& action,
                    bool scheduled,
                    bool recurring,
                    const String& nextTime) {
  String msg = "CMD;origin=" + origin +
               ";id=" + String(cmdId) +
               ";target=" + target +
               ";action=" + action +
               ";scheduled=" + (scheduled ? "1" : "0") +
               ";recurring=" + (recurring ? "1" : "0") +
               ";next=" + nextTime;
  return msg;
}



// Extract value after "key=" from semicolon-separated message
// e.g. msg="ACK;id=123;device=dev1;status=OK"
// extractField(msg,"device") -> "dev1"
String extractField(const String& msg, const String& key) {
  String pattern = key + "=";
  int start = msg.indexOf(pattern);
  if (start == -1) return "";

  start += pattern.length();
  int end = msg.indexOf(';', start);
  if (end == -1) {
    end = msg.length();
  }
  return msg.substring(start, end);
}

void connectWiFi() {
  Serial.print("[");
  Serial.print(CONTROLLER_ID);
  Serial.print("] Connecting to Wi-Fi: ");
  Serial.println(WIFI_SSID);

  WiFi.mode(WIFI_STA);
  WiFi.begin(WIFI_SSID, WIFI_PASSWORD);

  int attempts = 0;
  while (WiFi.status() != WL_CONNECTED && attempts < 40) {
    delay(250);
    Serial.print(".");
    attempts++;
  }
  Serial.println();

  if (WiFi.status() == WL_CONNECTED) {
    Serial.print("[");
    Serial.print(CONTROLLER_ID);
    Serial.print("] Wi-Fi connected. IP: ");
    Serial.println(WiFi.localIP());
  } else {
    Serial.print("[");
    Serial.print(CONTROLLER_ID);
    Serial.println("] Wi-Fi connection FAILED.");
  }
}

// Send one CLOSE_DOOR command to dev1
void sendCloseDoorToDev1() {
  Serial.println("[controller] sendCloseDoorToDev1() entered");
  commandCounter++;  // local to controller

  String origin = "controller";
  String target = "dev1";
  String action = "CLOSE_DOOR";

  String cmd = buildCommand(commandCounter,
                            origin,
                            target,
                            action,
                            false,   // scheduled
                            false,   // recurring
                            "NONE"); // next

  udp.beginPacket(broadcastIp, UDP_PORT);
  udp.print(cmd);
  udp.endPacket();

  Serial.print("[");
  Serial.print(CONTROLLER_ID);
  Serial.print("] Button press -> Sent command: ");
  Serial.println(cmd);

  logWifiStatus();
}

// Handle button with debounce; return true exactly ONCE per press
bool checkButtonPressed() {
  int reading = digitalRead(BUTTON_PIN);

  if (reading != lastReading) {
    lastDebounceTime = millis();  // reset debounce timer
  }
  lastReading = reading;

  if ((millis() - lastDebounceTime) > debounceDelay) {
    // Whatever the reading is at, it's been there long enough
    if (reading != lastStableButtonState) {
      lastStableButtonState = reading;

      // Button is wired to GND with INPUT_PULLUP:
      // LOW means "pressed"
      if (lastStableButtonState == LOW) {
        return true;
      }
    }
  }
  return false;
}

// ============= END HELPERS =============

void setup() {
  Serial.begin(115200);
  delay(500);

  Serial.print("\n=== Controller starting, ID = ");
  Serial.print(CONTROLLER_ID);
  Serial.println(" ===");

  pinMode(BUTTON_PIN, INPUT_PULLUP);
  connectWiFi();

  // Start UDP on the chosen port
  if (udp.begin(UDP_PORT)) {
    Serial.print("[");
    Serial.print(CONTROLLER_ID);
    Serial.print("] UDP started on port ");
    Serial.println(UDP_PORT);
  } else {
    Serial.print("[");
    Serial.print(CONTROLLER_ID);
    Serial.println("] Failed to start UDP!");
  }

  // Log initial Wi-Fi status
  logWifiStatus();
}

void loop() {
  static unsigned long lastPrint = 0;
  if (millis() - lastPrint > 1000) {
    lastPrint = millis();
    Serial.println("[controller] loop heartbeat");
  }

  unsigned long now = millis();

  // ===== TEST LOOPS =====
  // ---------- 1) Every 5 seconds: Wi-Fi status + command to dev1 ----------
  /* if (now - lastTickTime >= TICK_INTERVAL) {
    lastTickTime = now;

    // (a) Print Wi-Fi status to Serial
    logWifiStatus();

    // (b) Send command to dev1: CLOSE_DOOR
    commandCounter++;  // new command ID

    String target = "dev1";
    String action = "CLOSE_DOOR";
    String cmd    = buildCommand(commandCounter, target, action);

    udp.beginPacket(broadcastIp, UDP_PORT);
    udp.print(cmd);
    udp.endPacket();

    Serial.print("[");
    Serial.print(CONTROLLER_ID);
    Serial.print("] Sent command: ");
    Serial.println(cmd);
  }
  */
  // 1) Check for button press
  if (checkButtonPressed()) {
    Serial.print("[");
    Serial.print(CONTROLLER_ID);
    Serial.print("] checkButtonPressed() == true at ms=");
    Serial.println(millis());
    sendCloseDoorToDev1();
  }
  // ---------- 2) Listen for ACKs from devices ----------
  int packetSize = udp.parsePacket();
  if (packetSize > 0) {
    int len = udp.read(incomingBuffer, UDP_BUFFER_SIZE - 1);
    if (len > 0) {
      incomingBuffer[len] = '\0';
    }
    String msg = String(incomingBuffer);

    IPAddress senderIp   = udp.remoteIP();
    uint16_t senderPort  = udp.remotePort();

    Serial.print("[");
    Serial.print(CONTROLLER_ID);
    Serial.print("] Received UDP from ");
    Serial.print(senderIp);
    Serial.print(":");
    Serial.print(senderPort);
    Serial.print(" -> ");
    Serial.println(msg);

    // If this is an ACK, we can parse it
    // Expected: ACK;id=123;device=dev1;status=OK
    if (msg.startsWith("ACK;")) {
      String ackId   = extractField(msg, "id");
      String device  = extractField(msg, "device");
      String status  = extractField(msg, "status");

      Serial.print("[");
      Serial.print(CONTROLLER_ID);
      Serial.print("] Parsed ACK: id=");
      Serial.print(ackId);
      Serial.print(", device=");
      Serial.print(device);
      Serial.print(", status=");
      Serial.println(status);

      // If you only care about dev1:
      if (device == "dev1") {
        Serial.println("[controller] ACK from dev1 received.");
      }
    }
  }

  delay(10);
  // Ensure Wi-Fi stays connected 
  /* if (WiFi.status() != WL_CONNECTED) {
    Serial.print("[");
    Serial.print(CONTROLLER_ID);
    Serial.println("] Wi-Fi lost, reconnecting...");
    connectWiFi(); 
  } */
}
