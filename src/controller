/*
    ============================================================================
    DEVICE: controller (ESP32 dev board)
    PURPOSE:
      - Connects to Wi-Fi and listens for a physical button press
      - On button press, broadcasts a CMD over UDP to close the door on dev1
      - Listens for ACK messages from devices (e.g., dev1) and logs them
    ============================================================================
*/

#include <WiFi.h>
#include <WiFiUdp.h>

/* ============================================================================
 *  WIFI / UDP CONFIGURATION
 * ============================================================================ */
const char* WIFI_SSID     = "BlueHouse";
const char* WIFI_PASSWORD = "dynamicink599";
const uint16_t UDP_PORT   = 4210;                    // Shared port for all devices
IPAddress broadcastIp(192, 168, 86, 255);            // LAN broadcast address
const char* CONTROLLER_ID = "controller";            // Identity tag for this node

/* ============================================================================
 *  PHYSICAL INPUTS
 * ============================================================================ */
// Button on D2 (GPIO 2 on many ESP32 dev boards)
// Wiring: BUTTON_PIN → GND when pressed (using INPUT_PULLUP)
const int BUTTON_PIN = 2;

/* ============================================================================
 *  GLOBALS
 * ============================================================================ */
WiFiUDP udp;

const size_t UDP_BUFFER_SIZE = 256;
char incomingBuffer[UDP_BUFFER_SIZE];

unsigned long lastTickTime        = 0;        // For optional periodic tests
const unsigned long TICK_INTERVAL = 5000;     // 5 seconds (used in test code)

uint32_t commandCounter = 0;  // Incremented for each command sent from this controller

/* ============================================================================
 *  BUTTON DEBOUNCE STATE
 * ============================================================================ */
// We treat the button as:
//   - HIGH  = idle (not pressed)  [due to INPUT_PULLUP]
//   - LOW   = pressed (connected to GND)
int lastStableButtonState = HIGH;
int lastReading           = HIGH;
unsigned long lastDebounceTime   = 0;
const unsigned long debounceDelay = 50;      // 50 ms debounce window

/* ============================================================================
 *  WIFI STATUS LOGGER
 * ============================================================================ */
void logWifiStatus() {
  wl_status_t status = WiFi.status();

  Serial.print("[");
  Serial.print(CONTROLLER_ID);
  Serial.print("] WiFi status = ");
  Serial.print(status);  // 3 == WL_CONNECTED

  if (status == WL_CONNECTED) {
    Serial.print(" (CONNECTED), IP = ");
    Serial.print(WiFi.localIP());
    Serial.print(", RSSI = ");
    Serial.print(WiFi.RSSI());
    Serial.println(" dBm");
  } else {
    Serial.println(" (NOT CONNECTED)");
  }
}

/* ============================================================================
 *  COMMAND BUILDING HELPERS
 *  Build the text-based CMD protocol string
 * ============================================================================ */
// Example format (plain text):
//   CMD;origin=controller;id=5;target=dev1;action=CLOSE_DOOR;scheduled=0;recurring=0;next=NONE
String buildCommand(uint32_t cmdId,
                    const String& origin,
                    const String& target,
                    const String& action,
                    bool scheduled,
                    bool recurring,
                    const String& nextTime) {

  String msg =
    "CMD;origin="  + origin +
    ";id="         + String(cmdId) +
    ";target="     + target +
    ";action="     + action +
    ";scheduled="  + (scheduled ? "1" : "0") +
    ";recurring="  + (recurring ? "1" : "0") +
    ";next="       + nextTime;

  return msg;
}

/* ============================================================================
 *  GENERIC FIELD EXTRACTION
 *  Extract value after "key=" in a semicolon-separated message.
 *  Example:
 *    msg = "ACK;id=123;device=dev1;status=OK"
 *    extractField(msg, "device") -> "dev1"
 * ============================================================================ */
String extractField(const String& msg, const String& key) {
  String pattern = key + "=";
  int start = msg.indexOf(pattern);
  if (start == -1) return "";

  start += pattern.length();
  int end = msg.indexOf(';', start);
  if (end == -1) {
    end = msg.length();
  }
  return msg.substring(start, end);
}

/* ============================================================================
 *  WIFI CONNECTION LOGIC
 * ============================================================================ */
void connectWiFi() {
  Serial.print("[");
  Serial.print(CONTROLLER_ID);
  Serial.print("] Connecting to Wi-Fi: ");
  Serial.println(WIFI_SSID);

  WiFi.mode(WIFI_STA);
  WiFi.begin(WIFI_SSID, WIFI_PASSWORD);

  int attempts = 0;

  // Try up to 40 × (250ms) = 10 seconds
  while (WiFi.status() != WL_CONNECTED && attempts < 40) {
    delay(250);
    Serial.print(".");
    attempts++;
  }
  Serial.println();

  if (WiFi.status() == WL_CONNECTED) {
    Serial.print("[");
    Serial.print(CONTROLLER_ID);
    Serial.print("] Wi-Fi connected. IP: ");
    Serial.println(WiFi.localIP());
  } else {
    Serial.print("[");
    Serial.print(CONTROLLER_ID);
    Serial.println("] Wi-Fi connection FAILED.");
  }
}

/* ============================================================================
 *  SEND A CLOSE_DOOR COMMAND TO dev1
 * ============================================================================ */
void sendCloseDoorToDev1() {
  Serial.println("[controller] sendCloseDoorToDev1() entered");

  // Increment local command counter (unique per origin=controller)
  commandCounter++;

  String origin  = "controller";
  String target  = "dev1";
  String action  = "CLOSE_DOOR";

  // For controller button presses: manual, one-shot, no next recurrence
  String cmd = buildCommand(
    commandCounter,
    origin,
    target,
    action,
    false,       // scheduled
    false,       // recurring
    "NONE"       // next
  );

  // Broadcast command over UDP
  udp.beginPacket(broadcastIp, UDP_PORT);
  udp.print(cmd);
  udp.endPacket();

  Serial.print("[");
  Serial.print(CONTROLLER_ID);
  Serial.print("] Button press -> Sent command: ");
  Serial.println(cmd);

  // Optional: log Wi-Fi status whenever we send
  logWifiStatus();
}

/* ============================================================================
 *  BUTTON DEBOUNCE
 *  Returns true exactly once per physical press
 * ============================================================================ */
bool checkButtonPressed() {
  int reading = digitalRead(BUTTON_PIN);

  // Detect any change and reset debounce timer
  if (reading != lastReading) {
    lastDebounceTime = millis();
  }
  lastReading = reading;

  // If the reading has been stable longer than debounceDelay, treat it as valid
  if ((millis() - lastDebounceTime) > debounceDelay) {
    if (reading != lastStableButtonState) {
      lastStableButtonState = reading;

      // For INPUT_PULLUP: LOW = pressed
      if (lastStableButtonState == LOW) {
        return true;
      }
    }
  }
  return false;
}

/* ============================================================================
 *  SETUP
 * ============================================================================ */
void setup() {
  Serial.begin(115200);
  delay(500);

  Serial.print("\n=== Controller starting, ID = ");
  Serial.print(CONTROLLER_ID);
  Serial.println(" ===");

  pinMode(BUTTON_PIN, INPUT_PULLUP);

  connectWiFi();

  // Start UDP listener on the chosen port
  if (udp.begin(UDP_PORT)) {
    Serial.print("[");
    Serial.print(CONTROLLER_ID);
    Serial.print("] UDP started on port ");
    Serial.println(UDP_PORT);
  } else {
    Serial.print("[");
    Serial.print(CONTROLLER_ID);
    Serial.println("] Failed to start UDP!");
  }

  // Log initial Wi-Fi status
  logWifiStatus();
}

/* ============================================================================
 *  MAIN LOOP
 * ============================================================================ */
void loop() {
  unsigned long now = millis();

  /* ------------------------------------------------------------------------
   *  OPTIONAL TEST BLOCKS (disabled by default)
   * ------------------------------------------------------------------------
   */

  // Example heartbeat to verify loop is running (commented out)
  /*
  static unsigned long lastPrint = 0;
  if (now - lastPrint > 1000) {
    lastPrint = now;
    Serial.println("[controller] loop heartbeat");
  }
  */

  // Example periodic automatic command every TICK_INTERVAL (commented out)
  /*
  if (now - lastTickTime >= TICK_INTERVAL) {
    lastTickTime = now;

    logWifiStatus();

    commandCounter++;
    String target = "dev1";
    String action = "CLOSE_DOOR";
    String cmd    = buildCommand(commandCounter, "controller", target, action,
                                 true,  // scheduled
                                 false, // recurring
                                 "NONE");

    udp.beginPacket(broadcastIp, UDP_PORT);
    udp.print(cmd);
    udp.endPacket();

    Serial.print("[");
    Serial.print(CONTROLLER_ID);
    Serial.print("] Periodic test -> Sent command: ");
    Serial.println(cmd);
  }
  */

  /* ------------------------------------------------------------------------
   *  1) CHECK FOR BUTTON PRESS
   * ------------------------------------------------------------------------ */
  if (checkButtonPressed()) {
    Serial.print("[");
    Serial.print(CONTROLLER_ID);
    Serial.print("] checkButtonPressed() == true at ms = ");
    Serial.println(millis());

    sendCloseDoorToDev1();
  }

  /* ------------------------------------------------------------------------
   *  2) LISTEN FOR ACKS FROM DEVICES
   * ------------------------------------------------------------------------ */
  int packetSize = udp.parsePacket();
  if (packetSize > 0) {
    int len = udp.read(incomingBuffer, UDP_BUFFER_SIZE - 1);
    if (len > 0) {
      incomingBuffer[len] = '\0';
    }

    String msg = String(incomingBuffer);
    IPAddress senderIp  = udp.remoteIP();
    uint16_t senderPort = udp.remotePort();

    Serial.print("[");
    Serial.print(CONTROLLER_ID);
    Serial.print("] Received UDP from ");
    Serial.print(senderIp);
    Serial.print(":");
    Serial.print(senderPort);
    Serial.print(" -> ");
    Serial.println(msg);

    // Expect ACK messages like:
    // ACK;origin=controller;id=5;device=dev1;status=OK;scheduled=0;recurring=0;next=NONE
    if (msg.startsWith("ACK;")) {
      String ackId  = extractField(msg, "id");
      String device = extractField(msg, "device");
      String status = extractField(msg, "status");

      Serial.print("[");
      Serial.print(CONTROLLER_ID);
      Serial.print("] Parsed ACK: id=");
      Serial.print(ackId);
      Serial.print(", device=");
      Serial.print(device);
      Serial.print(", status=");
      Serial.println(status);

      if (device == "dev1") {
        Serial.println("[controller] ACK from dev1 received.");
      }
    }
  }

  /* ------------------------------------------------------------------------
   *  3) ENSURE WIFI STAYS CONNECTED
   * ------------------------------------------------------------------------ */
  if (WiFi.status() != WL_CONNECTED) {
    Serial.print("[");
    Serial.print(CONTROLLER_ID);
    Serial.println("] Wi-Fi lost, reconnecting...");
    connectWiFi();
  }

  // Short delay to avoid a too-tight loop
  delay(10);
}

/* ============================================================================
 *  END OF FILE
 * ============================================================================ */
